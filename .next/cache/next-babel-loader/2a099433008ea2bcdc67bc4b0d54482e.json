{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable import/prefer-default-export,class-methods-use-this */\n// application\nimport { AbstractFilterBuilder } from '~/fake-server/filters/abstract-filter-builder';\nimport { products as dbProducts } from '~/fake-server/database/products';\nexport class RatingFilterBuilder extends AbstractFilterBuilder {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"items\", []);\n\n    _defineProperty(this, \"value\", []);\n  }\n\n  test(product) {\n    if (this.value.length === 0) {\n      return true;\n    }\n\n    return this.value.reduce((acc, value) => acc || this.extractItem(product).rating === value, false);\n  }\n\n  makeItems(products, value) {\n    products.forEach(product => {\n      const item = this.extractItem(product);\n\n      if (!this.items.find(x => x.rating === item.rating)) {\n        this.items.push(item);\n      }\n    });\n    this.value = this.parseValue(value);\n    this.items.sort((a, b) => b.rating - a.rating);\n  }\n\n  calc(filters) {\n    const products = dbProducts.filter(product => filters.reduce((isMatched, filter) => isMatched && (filter === this || filter.test(product)), true));\n    this.items = this.items.map(item => _objectSpread(_objectSpread({}, item), {}, {\n      count: products.reduce((acc, product) => acc + (item.rating === this.extractItem(product).rating ? 1 : 0), 0)\n    }));\n  }\n\n  build() {\n    return {\n      type: 'rating',\n      slug: this.slug,\n      name: this.name,\n      items: this.items,\n      value: this.value\n    };\n  }\n\n  parseValue(value) {\n    return value ? value.split(',').map(x => parseFloat(x)) : [];\n  } // noinspection JSMethodCanBeStatic\n\n\n  extractItem(product) {\n    return {\n      rating: Math.round(product.rating || 0),\n      count: 0\n    };\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Shbaita Studio/Documents/project/new1/themeforest-irsnufCS-redparts-auto-parts-react-ecommerce-template/Sources/src/fake-server/filters/rating-filter-builder.ts"],"names":["AbstractFilterBuilder","products","dbProducts","RatingFilterBuilder","test","product","value","length","reduce","acc","extractItem","rating","makeItems","forEach","item","items","find","x","push","parseValue","sort","a","b","calc","filters","filter","isMatched","map","count","build","type","slug","name","split","parseFloat","Math","round"],"mappings":";;;;;;AAAA;AAEA;AACA,SAASA,qBAAT,QAAsC,+CAAtC;AAGA,SAASC,QAAQ,IAAIC,UAArB,QAAuC,iCAAvC;AAEA,OAAO,MAAMC,mBAAN,SAAkCH,qBAAlC,CAAwD;AAAA;AAAA;;AAAA,mCACtB,EADsB;;AAAA,mCAGjC,EAHiC;AAAA;;AAK3DI,EAAAA,IAAI,CAACC,OAAD,EAA6B;AAC7B,QAAI,KAAKC,KAAL,CAAWC,MAAX,KAAsB,CAA1B,EAA6B;AACzB,aAAO,IAAP;AACH;;AAED,WAAO,KAAKD,KAAL,CAAWE,MAAX,CAA2B,CAACC,GAAD,EAAMH,KAAN,KAAgBG,GAAG,IAAI,KAAKC,WAAL,CAAiBL,OAAjB,EAA0BM,MAA1B,KAAqCL,KAAvF,EAA8F,KAA9F,CAAP;AACH;;AAEDM,EAAAA,SAAS,CAACX,QAAD,EAAuBK,KAAvB,EAA4C;AACjDL,IAAAA,QAAQ,CAACY,OAAT,CAAkBR,OAAD,IAAa;AAC1B,YAAMS,IAAI,GAAG,KAAKJ,WAAL,CAAiBL,OAAjB,CAAb;;AAEA,UAAI,CAAC,KAAKU,KAAL,CAAWC,IAAX,CAAiBC,CAAD,IAAOA,CAAC,CAACN,MAAF,KAAaG,IAAI,CAACH,MAAzC,CAAL,EAAuD;AACnD,aAAKI,KAAL,CAAWG,IAAX,CAAgBJ,IAAhB;AACH;AACJ,KAND;AAQA,SAAKR,KAAL,GAAa,KAAKa,UAAL,CAAgBb,KAAhB,CAAb;AACA,SAAKS,KAAL,CAAWK,IAAX,CAAgB,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAAC,CAACX,MAAF,GAAWU,CAAC,CAACV,MAAvC;AACH;;AAEDY,EAAAA,IAAI,CAACC,OAAD,EAAyC;AACzC,UAAMvB,QAAQ,GAAGC,UAAU,CAACuB,MAAX,CACZpB,OAAD,IAAamB,OAAO,CAAChB,MAAR,CACT,CAACkB,SAAD,EAAYD,MAAZ,KAAwBC,SAAS,KAAKD,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACrB,IAAP,CAAYC,OAAZ,CAAxB,CADxB,EAET,IAFS,CADA,CAAjB;AAOA,SAAKU,KAAL,GAAa,KAAKA,KAAL,CAAWY,GAAX,CAAgBb,IAAD,oCACrBA,IADqB;AAExBc,MAAAA,KAAK,EAAE3B,QAAQ,CAACO,MAAT,CAAgB,CAACC,GAAD,EAAMJ,OAAN,KACnBI,GAAG,IAAIK,IAAI,CAACH,MAAL,KAAgB,KAAKD,WAAL,CAAiBL,OAAjB,EAA0BM,MAA1C,GAAmD,CAAnD,GAAuD,CAA3D,CADA,EAEJ,CAFI;AAFiB,MAAf,CAAb;AAMH;;AAEDkB,EAAAA,KAAK,GAAkB;AACnB,WAAO;AACHC,MAAAA,IAAI,EAAE,QADH;AAEHC,MAAAA,IAAI,EAAE,KAAKA,IAFR;AAGHC,MAAAA,IAAI,EAAE,KAAKA,IAHR;AAIHjB,MAAAA,KAAK,EAAE,KAAKA,KAJT;AAKHT,MAAAA,KAAK,EAAE,KAAKA;AALT,KAAP;AAOH;;AAEOa,EAAAA,UAAU,CAACb,KAAD,EAA0B;AACxC,WAAOA,KAAK,GAAGA,KAAK,CAAC2B,KAAN,CAAY,GAAZ,EAAiBN,GAAjB,CAAsBV,CAAD,IAAOiB,UAAU,CAACjB,CAAD,CAAtC,CAAH,GAAgD,EAA5D;AACH,GAtD0D,CAwD3D;;;AACQP,EAAAA,WAAW,CAACL,OAAD,EAAuC;AACtD,WAAO;AACHM,MAAAA,MAAM,EAAEwB,IAAI,CAACC,KAAL,CAAW/B,OAAO,CAACM,MAAR,IAAkB,CAA7B,CADL;AAEHiB,MAAAA,KAAK,EAAE;AAFJ,KAAP;AAIH;;AA9D0D","sourcesContent":["/* eslint-disable import/prefer-default-export,class-methods-use-this */\n\n// application\nimport { AbstractFilterBuilder } from '~/fake-server/filters/abstract-filter-builder';\nimport { IProduct } from '~/interfaces/product';\nimport { IRatingFilter, IRatingFilterItem } from '~/interfaces/filter';\nimport { products as dbProducts } from '~/fake-server/database/products';\n\nexport class RatingFilterBuilder extends AbstractFilterBuilder {\n    private items: IRatingFilterItem[] = [];\n\n    private value: number[] = [];\n\n    test(product: IProduct): boolean {\n        if (this.value.length === 0) {\n            return true;\n        }\n\n        return this.value.reduce<boolean>((acc, value) => acc || this.extractItem(product).rating === value, false);\n    }\n\n    makeItems(products: IProduct[], value: string): void {\n        products.forEach((product) => {\n            const item = this.extractItem(product);\n\n            if (!this.items.find((x) => x.rating === item.rating)) {\n                this.items.push(item);\n            }\n        });\n\n        this.value = this.parseValue(value);\n        this.items.sort((a, b) => b.rating - a.rating);\n    }\n\n    calc(filters: AbstractFilterBuilder[]): void {\n        const products = dbProducts.filter(\n            (product) => filters.reduce<boolean>(\n                (isMatched, filter) => (isMatched && (filter === this || filter.test(product))),\n                true,\n            ),\n        );\n\n        this.items = this.items.map((item) => ({\n            ...item,\n            count: products.reduce((acc, product) => (\n                acc + (item.rating === this.extractItem(product).rating ? 1 : 0)\n            ), 0),\n        }));\n    }\n\n    build(): IRatingFilter {\n        return {\n            type: 'rating',\n            slug: this.slug,\n            name: this.name,\n            items: this.items,\n            value: this.value,\n        };\n    }\n\n    private parseValue(value: string): number[] {\n        return value ? value.split(',').map((x) => parseFloat(x)) : [];\n    }\n\n    // noinspection JSMethodCanBeStatic\n    private extractItem(product: IProduct): IRatingFilterItem {\n        return {\n            rating: Math.round(product.rating || 0),\n            count: 0,\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}