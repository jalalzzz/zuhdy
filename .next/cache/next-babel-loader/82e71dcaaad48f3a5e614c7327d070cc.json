{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// react\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'; // third-party\n\nexport function useGlobalMousedown(callback, deps) {\n  _s();\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  var memoCallback = useCallback(callback, deps || []);\n  useEffect(function () {\n    document.addEventListener('mousedown', memoCallback);\n    return function () {\n      return document.removeEventListener('mousedown', memoCallback);\n    };\n  }, [memoCallback]);\n}\n\n_s(useGlobalMousedown, \"xsy62B694kV4FpvowihJrWW2K8E=\");\n\nexport function useDeferredData(source, defaultData, initialData) {\n  _s2();\n\n  var deps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  var _useState = useState(function () {\n    return {\n      isLoading: initialData === undefined,\n      data: initialData || defaultData\n    };\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var memoizedSource = useCallback(source, deps);\n  var skipNextRef = useRef(initialData !== undefined);\n  useEffect(function () {\n    if (skipNextRef.current) {\n      skipNextRef.current = false;\n      return function () {};\n    }\n\n    var canceled = false;\n    setState(function (curState) {\n      if (!curState.isLoading) {\n        return _objectSpread(_objectSpread({}, curState), {}, {\n          isLoading: true\n        });\n      }\n\n      return curState;\n    });\n    memoizedSource().then(function (data) {\n      if (canceled) {\n        return;\n      }\n\n      setState(function () {\n        return {\n          isLoading: false,\n          data: data\n        };\n      });\n    });\n    return function () {\n      canceled = true;\n    };\n  }, [memoizedSource]);\n  return state;\n}\n\n_s2(useDeferredData, \"nFFxTPgIfY3M/FcZjgaCwJcYCBs=\");\n\nexport function useProductTabs(tabs, productsSource, initialData) {\n  _s3();\n\n  var _useState2 = useState(1),\n      currentTabId = _useState2[0],\n      setCurrentTabId = _useState2[1];\n\n  var memoizedTabs = useMemo(function () {\n    return tabs.map(function (tab) {\n      return _objectSpread(_objectSpread({}, tab), {}, {\n        current: currentTabId === tab.id\n      });\n    });\n  }, [tabs, currentTabId]);\n  var currentTab = memoizedTabs.find(function (x) {\n    return x.current;\n  });\n  var products = useDeferredData(function () {\n    return currentTab ? productsSource(currentTab) : Promise.resolve([]);\n  }, [], initialData, [currentTab]);\n  var handleTabChange = useCallback(function (tab) {\n    setCurrentTabId(tab.id);\n  }, [setCurrentTabId]);\n  return useMemo(function () {\n    return _objectSpread({\n      tabs: memoizedTabs,\n      handleTabChange: handleTabChange\n    }, products);\n  }, [memoizedTabs, handleTabChange, products]);\n}\n\n_s3(useProductTabs, \"ruf1/dY4UnT/4/SSFFFaJa8b3iY=\", false, function () {\n  return [useDeferredData];\n});\n\nexport function useProductColumns(columns) {\n  _s4();\n\n  var products = useDeferredData(function () {\n    return Promise.all(columns.map(function (column) {\n      return column.source();\n    }));\n  }, [], undefined, [columns]);\n  return useMemo(function () {\n    return columns.map(function (column, index) {\n      return _objectSpread(_objectSpread({}, column), {}, {\n        products: products.data[index] || []\n      });\n    });\n  }, [columns, products]);\n}\n\n_s4(useProductColumns, \"nhBtKPM1Vs/7/fgpaIJ6Yetg/v8=\", false, function () {\n  return [useDeferredData];\n});\n\nexport function useDetachableForm(formMethods, detached) {\n  _s5();\n\n  var originalRegister = formMethods.register,\n      unregister = formMethods.unregister,\n      trigger = formMethods.trigger;\n  var fieldNamesRef = useRef([]);\n  useEffect(function () {\n    if (detached) {\n      unregister(fieldNamesRef.current);\n      fieldNamesRef.current = [];\n      trigger([]).then();\n    }\n  }, [detached, unregister, trigger]);\n  return function () {\n    var rules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return function (ref) {\n      if (!detached) {\n        if (ref && !fieldNamesRef.current.includes(ref.name)) {\n          fieldNamesRef.current.push(ref.name);\n        }\n\n        originalRegister(rules)(ref);\n      }\n    };\n  };\n}\n\n_s5(useDetachableForm, \"hQZ3VddtSNKCw2w5ngVGVzHgqgs=\");","map":{"version":3,"sources":["C:/Users/Shbaita Studio/Documents/project/new1/themeforest-irsnufCS-redparts-auto-parts-react-ecommerce-template/Sources/src/services/hooks.ts"],"names":["useCallback","useEffect","useMemo","useRef","useState","useGlobalMousedown","callback","deps","memoCallback","document","addEventListener","removeEventListener","useDeferredData","source","defaultData","initialData","isLoading","undefined","data","state","setState","memoizedSource","skipNextRef","current","canceled","curState","then","useProductTabs","tabs","productsSource","currentTabId","setCurrentTabId","memoizedTabs","map","tab","id","currentTab","find","x","products","Promise","resolve","handleTabChange","useProductColumns","columns","all","column","index","useDetachableForm","formMethods","detached","originalRegister","register","unregister","trigger","fieldNamesRef","rules","ref","includes","name","push"],"mappings":"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","sourcesContent":["// react\nimport {\n    DependencyList,\n    useCallback,\n    useEffect, useMemo,\n    useRef,\n    useState,\n} from 'react';\n// third-party\nimport { ValidationRules } from 'react-hook-form';\nimport {\n    FieldElement,\n    FieldName,\n    Ref,\n    UseFormMethods,\n} from 'react-hook-form/dist/types/form';\n// application\nimport { IProduct } from '~/interfaces/product';\n\nexport function useGlobalMousedown(callback: (event: MouseEvent) => void, deps?: DependencyList) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const memoCallback = useCallback(callback, deps || []);\n\n    useEffect(() => {\n        document.addEventListener('mousedown', memoCallback);\n\n        return () => document.removeEventListener('mousedown', memoCallback);\n    }, [memoCallback]);\n}\n\nexport type IDeferredDataSource<T> = () => Promise<T>;\nexport type IDeferredDataState<T> = { isLoading: boolean, data: T };\n\nexport function useDeferredData<T>(\n    source: IDeferredDataSource<T>,\n    defaultData: T,\n    initialData?: T,\n    deps: any[] = [],\n): IDeferredDataState<T> {\n    const [state, setState] = useState(() => ({\n        isLoading: initialData === undefined,\n        data: initialData || defaultData,\n    }));\n    const memoizedSource = useCallback(source, deps);\n    const skipNextRef = useRef(initialData !== undefined);\n\n    useEffect(() => {\n        if (skipNextRef.current) {\n            skipNextRef.current = false;\n\n            return () => {};\n        }\n\n        let canceled = false;\n\n        setState((curState) => {\n            if (!curState.isLoading) {\n                return { ...curState, isLoading: true };\n            }\n\n            return curState;\n        });\n\n        memoizedSource().then((data) => {\n            if (canceled) {\n                return;\n            }\n\n            setState(() => ({ isLoading: false, data }));\n        });\n\n        return () => {\n            canceled = true;\n        };\n    }, [memoizedSource]);\n\n    return state;\n}\n\nexport type IProductTab = { id: number; name: string };\nexport type IWithCurrent<T> = T & {current: boolean};\nexport type IProductTabSource<T extends IProductTab> = (tab: T) => Promise<IProduct[]>;\nexport type IProductTabsState<T extends IProductTab> = {\n    tabs: IWithCurrent<T>[];\n    handleTabChange: (tab: IWithCurrent<T>) => void;\n} & IDeferredDataState<IProduct[]>;\n\nexport function useProductTabs<T extends IProductTab>(\n    tabs: T[],\n    productsSource: IProductTabSource<T>,\n    initialData?: IProduct[],\n): IProductTabsState<T> {\n    const [currentTabId, setCurrentTabId] = useState(1);\n    const memoizedTabs = useMemo(() => (\n        tabs.map((tab) => ({\n            ...tab,\n            current: currentTabId === tab.id,\n        }))\n    ), [tabs, currentTabId]);\n    const currentTab = memoizedTabs.find((x) => x.current);\n    const products = useDeferredData(() => (\n        currentTab ? productsSource(currentTab) : Promise.resolve([])\n    ), [], initialData, [currentTab]);\n    const handleTabChange = useCallback((tab) => {\n        setCurrentTabId(tab.id);\n    }, [setCurrentTabId]);\n\n    return useMemo(() => ({\n        tabs: memoizedTabs,\n        handleTabChange,\n        ...products,\n    }), [memoizedTabs, handleTabChange, products]);\n}\n\nexport type IProductColumn = {\n    title: string;\n    source: IDeferredDataSource<IProduct[]>;\n};\n\nexport function useProductColumns(columns: IProductColumn[]) {\n    const products = useDeferredData(() => (\n        Promise.all(columns.map((column) => column.source()))\n    ), [], undefined, [columns]);\n\n    return useMemo(() => (\n        columns.map((column, index) => ({\n            ...column,\n            products: products.data[index] || [],\n        }))\n    ), [columns, products]);\n}\n\nexport function useDetachableForm<T extends Record<string, any>>(formMethods: UseFormMethods<T>, detached: boolean) {\n    const { register: originalRegister, unregister, trigger } = formMethods;\n\n    const fieldNamesRef = useRef<(string | FieldName<T>)[]>([]);\n\n    useEffect(() => {\n        if (detached) {\n            unregister(fieldNamesRef.current as FieldName<T>[]);\n\n            fieldNamesRef.current = [];\n            trigger([]).then();\n        }\n    }, [detached, unregister, trigger]);\n\n    return (rules: ValidationRules = {}) => (ref: FieldElement<T> & Ref | null) => {\n        if (!detached) {\n            if (ref && !fieldNamesRef.current.includes(ref.name)) {\n                fieldNamesRef.current.push(ref.name);\n            }\n\n            originalRegister(rules)(ref);\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}