{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// react\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'; // third-party\n\nexport function useGlobalMousedown(callback, deps) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const memoCallback = useCallback(callback, deps || []);\n  useEffect(() => {\n    document.addEventListener('mousedown', memoCallback);\n    return () => document.removeEventListener('mousedown', memoCallback);\n  }, [memoCallback]);\n}\nexport function useDeferredData(source, defaultData, initialData, deps = []) {\n  const {\n    0: state,\n    1: setState\n  } = useState(() => ({\n    isLoading: initialData === undefined,\n    data: initialData || defaultData\n  }));\n  const memoizedSource = useCallback(source, deps);\n  const skipNextRef = useRef(initialData !== undefined);\n  useEffect(() => {\n    if (skipNextRef.current) {\n      skipNextRef.current = false;\n      return () => {};\n    }\n\n    let canceled = false;\n    setState(curState => {\n      if (!curState.isLoading) {\n        return _objectSpread(_objectSpread({}, curState), {}, {\n          isLoading: true\n        });\n      }\n\n      return curState;\n    });\n    memoizedSource().then(data => {\n      if (canceled) {\n        return;\n      }\n\n      setState(() => ({\n        isLoading: false,\n        data\n      }));\n    });\n    return () => {\n      canceled = true;\n    };\n  }, [memoizedSource]);\n  return state;\n}\nexport function useProductTabs(tabs, productsSource, initialData) {\n  const {\n    0: currentTabId,\n    1: setCurrentTabId\n  } = useState(1);\n  const memoizedTabs = useMemo(() => tabs.map(tab => _objectSpread(_objectSpread({}, tab), {}, {\n    current: currentTabId === tab.id\n  })), [tabs, currentTabId]);\n  const currentTab = memoizedTabs.find(x => x.current);\n  const products = useDeferredData(() => currentTab ? productsSource(currentTab) : Promise.resolve([]), [], initialData, [currentTab]);\n  const handleTabChange = useCallback(tab => {\n    setCurrentTabId(tab.id);\n  }, [setCurrentTabId]);\n  return useMemo(() => _objectSpread({\n    tabs: memoizedTabs,\n    handleTabChange\n  }, products), [memoizedTabs, handleTabChange, products]);\n}\nexport function useProductColumns(columns) {\n  const products = useDeferredData(() => Promise.all(columns.map(column => column.source())), [], undefined, [columns]);\n  return useMemo(() => columns.map((column, index) => _objectSpread(_objectSpread({}, column), {}, {\n    products: products.data[index] || []\n  })), [columns, products]);\n}\nexport function useDetachableForm(formMethods, detached) {\n  const {\n    register: originalRegister,\n    unregister,\n    trigger\n  } = formMethods;\n  const fieldNamesRef = useRef([]);\n  useEffect(() => {\n    if (detached) {\n      unregister(fieldNamesRef.current);\n      fieldNamesRef.current = [];\n      trigger([]).then();\n    }\n  }, [detached, unregister, trigger]);\n  return (rules = {}) => ref => {\n    if (!detached) {\n      if (ref && !fieldNamesRef.current.includes(ref.name)) {\n        fieldNamesRef.current.push(ref.name);\n      }\n\n      originalRegister(rules)(ref);\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/Shbaita Studio/Documents/project/new1/themeforest-irsnufCS-redparts-auto-parts-react-ecommerce-template/Sources/src/services/hooks.ts"],"names":["useCallback","useEffect","useMemo","useRef","useState","useGlobalMousedown","callback","deps","memoCallback","document","addEventListener","removeEventListener","useDeferredData","source","defaultData","initialData","state","setState","isLoading","undefined","data","memoizedSource","skipNextRef","current","canceled","curState","then","useProductTabs","tabs","productsSource","currentTabId","setCurrentTabId","memoizedTabs","map","tab","id","currentTab","find","x","products","Promise","resolve","handleTabChange","useProductColumns","columns","all","column","index","useDetachableForm","formMethods","detached","register","originalRegister","unregister","trigger","fieldNamesRef","rules","ref","includes","name","push"],"mappings":";;;;;;AAAA;AACA,SAEIA,WAFJ,EAGIC,SAHJ,EAGeC,OAHf,EAIIC,MAJJ,EAKIC,QALJ,QAMO,OANP,C,CAOA;;AAWA,OAAO,SAASC,kBAAT,CAA4BC,QAA5B,EAAmEC,IAAnE,EAA0F;AAC7F;AACA,QAAMC,YAAY,GAAGR,WAAW,CAACM,QAAD,EAAWC,IAAI,IAAI,EAAnB,CAAhC;AAEAN,EAAAA,SAAS,CAAC,MAAM;AACZQ,IAAAA,QAAQ,CAACC,gBAAT,CAA0B,WAA1B,EAAuCF,YAAvC;AAEA,WAAO,MAAMC,QAAQ,CAACE,mBAAT,CAA6B,WAA7B,EAA0CH,YAA1C,CAAb;AACH,GAJQ,EAIN,CAACA,YAAD,CAJM,CAAT;AAKH;AAKD,OAAO,SAASI,eAAT,CACHC,MADG,EAEHC,WAFG,EAGHC,WAHG,EAIHR,IAAW,GAAG,EAJX,EAKkB;AACrB,QAAM;AAAA,OAACS,KAAD;AAAA,OAAQC;AAAR,MAAoBb,QAAQ,CAAC,OAAO;AACtCc,IAAAA,SAAS,EAAEH,WAAW,KAAKI,SADW;AAEtCC,IAAAA,IAAI,EAAEL,WAAW,IAAID;AAFiB,GAAP,CAAD,CAAlC;AAIA,QAAMO,cAAc,GAAGrB,WAAW,CAACa,MAAD,EAASN,IAAT,CAAlC;AACA,QAAMe,WAAW,GAAGnB,MAAM,CAACY,WAAW,KAAKI,SAAjB,CAA1B;AAEAlB,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAIqB,WAAW,CAACC,OAAhB,EAAyB;AACrBD,MAAAA,WAAW,CAACC,OAAZ,GAAsB,KAAtB;AAEA,aAAO,MAAM,CAAE,CAAf;AACH;;AAED,QAAIC,QAAQ,GAAG,KAAf;AAEAP,IAAAA,QAAQ,CAAEQ,QAAD,IAAc;AACnB,UAAI,CAACA,QAAQ,CAACP,SAAd,EAAyB;AACrB,+CAAYO,QAAZ;AAAsBP,UAAAA,SAAS,EAAE;AAAjC;AACH;;AAED,aAAOO,QAAP;AACH,KANO,CAAR;AAQAJ,IAAAA,cAAc,GAAGK,IAAjB,CAAuBN,IAAD,IAAU;AAC5B,UAAII,QAAJ,EAAc;AACV;AACH;;AAEDP,MAAAA,QAAQ,CAAC,OAAO;AAAEC,QAAAA,SAAS,EAAE,KAAb;AAAoBE,QAAAA;AAApB,OAAP,CAAD,CAAR;AACH,KAND;AAQA,WAAO,MAAM;AACTI,MAAAA,QAAQ,GAAG,IAAX;AACH,KAFD;AAGH,GA5BQ,EA4BN,CAACH,cAAD,CA5BM,CAAT;AA8BA,SAAOL,KAAP;AACH;AAUD,OAAO,SAASW,cAAT,CACHC,IADG,EAEHC,cAFG,EAGHd,WAHG,EAIiB;AACpB,QAAM;AAAA,OAACe,YAAD;AAAA,OAAeC;AAAf,MAAkC3B,QAAQ,CAAC,CAAD,CAAhD;AACA,QAAM4B,YAAY,GAAG9B,OAAO,CAAC,MACzB0B,IAAI,CAACK,GAAL,CAAUC,GAAD,oCACFA,GADE;AAELX,IAAAA,OAAO,EAAEO,YAAY,KAAKI,GAAG,CAACC;AAFzB,IAAT,CADwB,EAKzB,CAACP,IAAD,EAAOE,YAAP,CALyB,CAA5B;AAMA,QAAMM,UAAU,GAAGJ,YAAY,CAACK,IAAb,CAAmBC,CAAD,IAAOA,CAAC,CAACf,OAA3B,CAAnB;AACA,QAAMgB,QAAQ,GAAG3B,eAAe,CAAC,MAC7BwB,UAAU,GAAGP,cAAc,CAACO,UAAD,CAAjB,GAAgCI,OAAO,CAACC,OAAR,CAAgB,EAAhB,CADd,EAE7B,EAF6B,EAEzB1B,WAFyB,EAEZ,CAACqB,UAAD,CAFY,CAAhC;AAGA,QAAMM,eAAe,GAAG1C,WAAW,CAAEkC,GAAD,IAAS;AACzCH,IAAAA,eAAe,CAACG,GAAG,CAACC,EAAL,CAAf;AACH,GAFkC,EAEhC,CAACJ,eAAD,CAFgC,CAAnC;AAIA,SAAO7B,OAAO,CAAC;AACX0B,IAAAA,IAAI,EAAEI,YADK;AAEXU,IAAAA;AAFW,KAGRH,QAHQ,CAAD,EAIV,CAACP,YAAD,EAAeU,eAAf,EAAgCH,QAAhC,CAJU,CAAd;AAKH;AAOD,OAAO,SAASI,iBAAT,CAA2BC,OAA3B,EAAsD;AACzD,QAAML,QAAQ,GAAG3B,eAAe,CAAC,MAC7B4B,OAAO,CAACK,GAAR,CAAYD,OAAO,CAACX,GAAR,CAAaa,MAAD,IAAYA,MAAM,CAACjC,MAAP,EAAxB,CAAZ,CAD4B,EAE7B,EAF6B,EAEzBM,SAFyB,EAEd,CAACyB,OAAD,CAFc,CAAhC;AAIA,SAAO1C,OAAO,CAAC,MACX0C,OAAO,CAACX,GAAR,CAAY,CAACa,MAAD,EAASC,KAAT,qCACLD,MADK;AAERP,IAAAA,QAAQ,EAAEA,QAAQ,CAACnB,IAAT,CAAc2B,KAAd,KAAwB;AAF1B,IAAZ,CADU,EAKX,CAACH,OAAD,EAAUL,QAAV,CALW,CAAd;AAMH;AAED,OAAO,SAASS,iBAAT,CAA0DC,WAA1D,EAA0FC,QAA1F,EAA6G;AAChH,QAAM;AAAEC,IAAAA,QAAQ,EAAEC,gBAAZ;AAA8BC,IAAAA,UAA9B;AAA0CC,IAAAA;AAA1C,MAAsDL,WAA5D;AAEA,QAAMM,aAAa,GAAGpD,MAAM,CAA4B,EAA5B,CAA5B;AAEAF,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAIiD,QAAJ,EAAc;AACVG,MAAAA,UAAU,CAACE,aAAa,CAAChC,OAAf,CAAV;AAEAgC,MAAAA,aAAa,CAAChC,OAAd,GAAwB,EAAxB;AACA+B,MAAAA,OAAO,CAAC,EAAD,CAAP,CAAY5B,IAAZ;AACH;AACJ,GAPQ,EAON,CAACwB,QAAD,EAAWG,UAAX,EAAuBC,OAAvB,CAPM,CAAT;AASA,SAAO,CAACE,KAAsB,GAAG,EAA1B,KAAkCC,GAAD,IAAuC;AAC3E,QAAI,CAACP,QAAL,EAAe;AACX,UAAIO,GAAG,IAAI,CAACF,aAAa,CAAChC,OAAd,CAAsBmC,QAAtB,CAA+BD,GAAG,CAACE,IAAnC,CAAZ,EAAsD;AAClDJ,QAAAA,aAAa,CAAChC,OAAd,CAAsBqC,IAAtB,CAA2BH,GAAG,CAACE,IAA/B;AACH;;AAEDP,MAAAA,gBAAgB,CAACI,KAAD,CAAhB,CAAwBC,GAAxB;AACH;AACJ,GARD;AASH","sourcesContent":["// react\nimport {\n    DependencyList,\n    useCallback,\n    useEffect, useMemo,\n    useRef,\n    useState,\n} from 'react';\n// third-party\nimport { ValidationRules } from 'react-hook-form';\nimport {\n    FieldElement,\n    FieldName,\n    Ref,\n    UseFormMethods,\n} from 'react-hook-form/dist/types/form';\n// application\nimport { IProduct } from '~/interfaces/product';\n\nexport function useGlobalMousedown(callback: (event: MouseEvent) => void, deps?: DependencyList) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const memoCallback = useCallback(callback, deps || []);\n\n    useEffect(() => {\n        document.addEventListener('mousedown', memoCallback);\n\n        return () => document.removeEventListener('mousedown', memoCallback);\n    }, [memoCallback]);\n}\n\nexport type IDeferredDataSource<T> = () => Promise<T>;\nexport type IDeferredDataState<T> = { isLoading: boolean, data: T };\n\nexport function useDeferredData<T>(\n    source: IDeferredDataSource<T>,\n    defaultData: T,\n    initialData?: T,\n    deps: any[] = [],\n): IDeferredDataState<T> {\n    const [state, setState] = useState(() => ({\n        isLoading: initialData === undefined,\n        data: initialData || defaultData,\n    }));\n    const memoizedSource = useCallback(source, deps);\n    const skipNextRef = useRef(initialData !== undefined);\n\n    useEffect(() => {\n        if (skipNextRef.current) {\n            skipNextRef.current = false;\n\n            return () => {};\n        }\n\n        let canceled = false;\n\n        setState((curState) => {\n            if (!curState.isLoading) {\n                return { ...curState, isLoading: true };\n            }\n\n            return curState;\n        });\n\n        memoizedSource().then((data) => {\n            if (canceled) {\n                return;\n            }\n\n            setState(() => ({ isLoading: false, data }));\n        });\n\n        return () => {\n            canceled = true;\n        };\n    }, [memoizedSource]);\n\n    return state;\n}\n\nexport type IProductTab = { id: number; name: string };\nexport type IWithCurrent<T> = T & {current: boolean};\nexport type IProductTabSource<T extends IProductTab> = (tab: T) => Promise<IProduct[]>;\nexport type IProductTabsState<T extends IProductTab> = {\n    tabs: IWithCurrent<T>[];\n    handleTabChange: (tab: IWithCurrent<T>) => void;\n} & IDeferredDataState<IProduct[]>;\n\nexport function useProductTabs<T extends IProductTab>(\n    tabs: T[],\n    productsSource: IProductTabSource<T>,\n    initialData?: IProduct[],\n): IProductTabsState<T> {\n    const [currentTabId, setCurrentTabId] = useState(1);\n    const memoizedTabs = useMemo(() => (\n        tabs.map((tab) => ({\n            ...tab,\n            current: currentTabId === tab.id,\n        }))\n    ), [tabs, currentTabId]);\n    const currentTab = memoizedTabs.find((x) => x.current);\n    const products = useDeferredData(() => (\n        currentTab ? productsSource(currentTab) : Promise.resolve([])\n    ), [], initialData, [currentTab]);\n    const handleTabChange = useCallback((tab) => {\n        setCurrentTabId(tab.id);\n    }, [setCurrentTabId]);\n\n    return useMemo(() => ({\n        tabs: memoizedTabs,\n        handleTabChange,\n        ...products,\n    }), [memoizedTabs, handleTabChange, products]);\n}\n\nexport type IProductColumn = {\n    title: string;\n    source: IDeferredDataSource<IProduct[]>;\n};\n\nexport function useProductColumns(columns: IProductColumn[]) {\n    const products = useDeferredData(() => (\n        Promise.all(columns.map((column) => column.source()))\n    ), [], undefined, [columns]);\n\n    return useMemo(() => (\n        columns.map((column, index) => ({\n            ...column,\n            products: products.data[index] || [],\n        }))\n    ), [columns, products]);\n}\n\nexport function useDetachableForm<T extends Record<string, any>>(formMethods: UseFormMethods<T>, detached: boolean) {\n    const { register: originalRegister, unregister, trigger } = formMethods;\n\n    const fieldNamesRef = useRef<(string | FieldName<T>)[]>([]);\n\n    useEffect(() => {\n        if (detached) {\n            unregister(fieldNamesRef.current as FieldName<T>[]);\n\n            fieldNamesRef.current = [];\n            trigger([]).then();\n        }\n    }, [detached, unregister, trigger]);\n\n    return (rules: ValidationRules = {}) => (ref: FieldElement<T> & Ref | null) => {\n        if (!detached) {\n            if (ref && !fieldNamesRef.current.includes(ref.name)) {\n                fieldNamesRef.current.push(ref.name);\n            }\n\n            originalRegister(rules)(ref);\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}